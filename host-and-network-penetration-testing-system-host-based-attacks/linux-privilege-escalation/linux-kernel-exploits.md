# Linux Kernel Exploits

<figure><img src="../../.gitbook/assets/image (944).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (945).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
ATTENZIONE: Kernel Exploits non compatibili con la versione di kernel del target può comportare server crash, kernel panic e conseguente perdita di dati. Fare quindi molta attenzione ad eseguire Kernel exploits in ambienti di produzione o enterprise.
{% endhint %}

## Local enumeration

Nel nostro laboratorio partiamo dalla situazione in cui abbiamo già ottenuto accesso al target tramite degli exploit e quindi facciamo come prima cosa un po' di local enumeration:

```
sysinfo
getuid

```

<figure><img src="../../.gitbook/assets/image (946).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (947).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (948).png" alt=""><figcaption></figcaption></figure>

Come vediamo l'utente www-data non ha nessun permesso sudo per cui dobbiamo fare privilege escalation e puntiamo ovviamente a farla verso l'utente root.

## Privesc con Linux Exploit Suggester tool

è uno shell script molto semplice da usare

<figure><img src="../../.gitbook/assets/image (950).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (951).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (952).png" alt=""><figcaption></figcaption></figure>

è suggerito scaricare LES sulla macchina attaccante e poi trasferirlo sulla vittima per eseguirlo.

In questo caso abbiamo una meterpreter shell quindi sarà più semplice:

```
cd /temp
ls
upload Desktop/Linux-Enum/les.sh
shell
ls -al
chmod +x les.sh
ls -alps
./les.sh
```

<figure><img src="../../.gitbook/assets/image (953).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (954).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (955).png" alt=""><figcaption></figcaption></figure>

Eseguendo LES ci verranno mostrate una serie di exploits per i quali la nostra specifica versione del kernel è vulnerabile.

In particolare il pezzo più importante per fare kernel exploitation è contenuto nelle prima righe del risultato:

<figure><img src="../../.gitbook/assets/image (956).png" alt=""><figcaption></figcaption></figure>

Gli exploit elencati all'inizio sono quelli con maggior probabilità di successo, tuttavia bisogn afare attenzione alla descrizione di ogni exploit per verificarne l'effettiva compatibilità, in particolare details, exposure e tags:

<figure><img src="../../.gitbook/assets/image (957).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (958).png" alt=""><figcaption></figcaption></figure>

Verifichiamo questo exploit dirtycow che è il primo.

<figure><img src="../../.gitbook/assets/image (959).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (960).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (961).png" alt=""><figcaption></figcaption></figure>

Le azioni da fare elencate nel commento qui sopra del codice sono:

* Compilare
* Eseguire il binary appena creato

### Scarichiamo il codice dell'exploit

Scarichiamo quindi il programma scritto in C da Exploit Database:

<figure><img src="../../.gitbook/assets/image (962).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (963).png" alt=""><figcaption></figcaption></figure>

Riguardo a compilarlo si può fare o localmente sulla macchina attaccante, oppure trasferire il codice C sulla vittima e compilarlo sulla vittima.

### Compiliamo il codice C

Lo compiliamo sulla macchina attaccante in questo caso e poi lo trasferiamo alla vittima, se non funziona si può compilare direttamente sulla vittima.

<figure><img src="../../.gitbook/assets/image (964).png" alt=""><figcaption></figcaption></figure>

### Uploadiamo l'eseguibile sulla vittima e lo eseguiamo

<figure><img src="../../.gitbook/assets/image (965).png" alt=""><figcaption></figcaption></figure>

In questo caso ci ritorna errore perché non è stato compilato sulla macchina vittima stessa.

Quindi ora carichiamo il codice C e lo compiliamo sulla vittima e poi lo eseguiamo:

<figure><img src="../../.gitbook/assets/image (966).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (967).png" alt=""><figcaption></figcaption></figure>

Quando si esegue il binario e quindi l'exploit viene fatto un backup del vecchio file /etc/passwd in modo da salvare la vecchia password qualora si voglia tornare indietro.

E ha creato l'utente firefart con la password specificata.

Verifichiamo se l'utente firefart è stato creato controllando il file /etc/passwd:

<figure><img src="../../.gitbook/assets/image (968).png" alt=""><figcaption></figcaption></figure>

E possiamo notare che l'utente è stato creato ed ha anche permessi di root.

Per cambiare al nuovo utente:

<figure><img src="../../.gitbook/assets/image (969).png" alt=""><figcaption></figcaption></figure>

Ma in questo caso ci da questo errore, quindi possiamo connetterci via SSH con questo nuovo utente per avere una connessione diretta e pulita

### Connettersi via SSH alla vittima con nuovo utente creato dall'exploit

<figure><img src="../../.gitbook/assets/image (970).png" alt=""><figcaption></figcaption></figure>

Ci dà un errore sulla chiave certificato, ma è un problema sulla macchina attaccante quindi la rimuoviamo con il comando suggerito, ci ricolleghiamo accettando il certificato e ora siamo connessi alla vittima con l'utente firefart appena creato dall'exploit e abbiamo permessi amministrativi, infatti possiamo eseguire un update ad esempio:

<figure><img src="../../.gitbook/assets/image (971).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (972).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (973).png" alt=""><figcaption></figcaption></figure>

Il file /etc/shadow è accessibile solo tramite account privilegiati poiché contiene gli hash delle password.

Tra l'altro questo file tornerà utile dopo quando vedremo il dump delle credenziali in Linux.
